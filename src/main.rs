use std::env;
use std::fs;
use std::io::Write;
use std::process;

mod cli;

use fidlcrs::compiler::Compiler;
use fidlcrs::lexer::Lexer;
use fidlcrs::parser::Parser;
use fidlcrs::reporter::Reporter;
use fidlcrs::source_file::SourceFile;
use fidlcrs::token::TokenKind;

fn usage() {
    println!(r#"The FIDL compiler

Usage: fidlc [--json JSON_PATH]
             [--available PLATFORM:VERSION[,VERSION]...]
             [--versioned PLATFORM[:VERSION]]
             [--name LIBRARY_NAME]
             [--experimental FLAG_NAME]
             [--werror]
             [--format=[text|json]]
             [--json-schema]
             [--depfile DEPFILE_PATH]
             [--files [FIDL_FILE...]...]
             [--help]

All of the arguments can also be provided via a response file, denoted as
`@responsefile`. The contents of the file at `responsefile` will be interpreted
as a whitespace-delimited list of arguments. Response files cannot be nested.

See <https://fuchsia.dev/fuchsia-src/development/languages/fidl/reference/compiler>
for more information.

Options:

 * `--json JSON_PATH`. If present, this flag instructs `fidlc` to output the
   library's intermediate representation at the given path. The intermediate
   representation is JSON that conforms to the schema available via --json-schema.
   The intermediate representation is used as input to the various backends.

 * `--available PLATFORM:VERSION[,VERSION]...`. If present, this flag instructs `fidlc`
   to include elements annotated `@available` under PLATFORM at any given VERSION.
   PLATFORM corresponds to a library's `@available(platform="PLATFORM")` attribute,
   or to the library name's first component if the `platform` argument is omitted.
   E.g. `--available example:1,3` selects versions 1 and 3 of platform "example".

 * `--versioned PLATFORM[:VERSION]`. If present, this flag instructs `fidlc` to
   validate that the main library being compiled is versioned under PLATFORM.
   If VERSION is provided, also validates that the library is added at VERSION.
   The library's platform is determined as follows:
    * If there are no `@available` attributes, the platform is "unversioned".
    * The platform can be explicit with `@available(platform="PLATFORM")`.
    * Otherwise, the platform is the first component of the library name.

 * `--name LIBRARY_NAME`. If present, this flag instructs `fidlc` to validate
   that the main library being compiled has the given name. This flag is useful
   to cross-check between the library's declaration in a build system and the
   actual contents of the library.

 * `--experimental FLAG_NAME`. If present, this flag enables an experimental
    feature of fidlc.

 * `--depfile DEPFILE_PATH`. Path of depfile generated by `fidlc`. This depfile is
   used to get correct incremental compilation rules. This file is populated by fidlc
   as Line1: out1: in1 in2 in3, Line2: out2: in1 in2 in3 ... Where out[1-2] are all the
   outputs generated by fidlc and in[1-3] are the files read. The input files are
   what are passed by --files. Output files are those generated by fidlc.

 * `--files [FIDL_FILE...]...`. Each `--files [FIDL_FILE...]` chunk of arguments
   describes a library, all of which must share the same top-level library name
   declaration. Libraries must be presented in dependency order, with later
   libraries able to use declarations from preceding libraries but not vice versa.
   Output is only generated for the final library, not for each of its dependencies.

 * `--json-schema`. If present, this flag instructs `fidlc` to output the
   JSON schema of the intermediate representation.

 * `--format=[text|json]`. If present, this flag sets the output mode of `fidlc`.
    This specifies whether to output errors and warnings, if compilation fails, in
    plain text (the default), or as JSON.

 * `--werror`. Treats warnings as errors.

 * `--help`. Prints this help, and exit immediately.
"#);
}

fn fail_with_usage(msg: &str) -> ! {
    eprintln!("{}", msg);
    usage();
    process::exit(1);
}

fn fail(msg: &str) -> ! {
    eprintln!("{}", msg);
    process::exit(1);
}

fn main() {
    let raw_args: Vec<String> = env::args().collect();
    let mut args = cli::Arguments::new(raw_args);

    args.claim(); // program name

    if !args.remaining() {
        usage();
        process::exit(0);
    }

    let mut json_path: Option<String> = None;
    let mut _warnings_as_errors = false;
    let mut _format = "text".to_string();
    let mut _expected_library_name: Option<String> = None;
    let _expected_platform: Option<String> = None;
    let _expected_version_added: Option<String> = None;
    let mut dep_file_path: Option<String> = None;

    // We collect files divided by `--files` chunks
    // Currently fidlcrs only compiles a single file for the main library
    // We'll collect the files, but we'll probably only use the first one as before,
    // or run them in sequence if fidlcrs supports it.
    let mut source_managers: Vec<Vec<String>> = Vec::new();

    while args.remaining() {
        let flag = args.claim();

        if flag == "--help" {
            usage();
            process::exit(0);
        } else if flag == "--json-schema" {
            // output schema
            println!("{{}}"); // not genuinely implementing it right now
            process::exit(0);
        } else if flag == "--werror" {
            _warnings_as_errors = true;
        } else if flag.starts_with("--format=") {
            let format_val = &flag["--format=".len()..];
            if format_val != "text" && format_val != "json" {
                fail_with_usage(&format!("Unknown value `{}` for flag `format`\n", format_val));
            }
            _format = format_val.to_string();
        } else if flag == "--json" {
            json_path = Some(args.claim());
        } else if flag == "--available" {
            let _arg = args.claim();
            // Not fully implementing parsed available versions right now, just skipping
        } else if flag == "--versioned" {
            let _arg = args.claim();
            // fake parsing platform and version
        } else if flag == "--name" {
            _expected_library_name = Some(args.claim());
        } else if flag == "--experimental" {
            let _flag_name = args.claim();
        } else if flag == "--depfile" {
            dep_file_path = Some(args.claim());
        } else if flag == "--files" {
            // breaking out to files parsing
            break;
        } else {
            fail_with_usage(&format!("Unknown argument: {}\n", flag));
        }
    }

    source_managers.push(Vec::new());

    while args.remaining() {
        let arg = args.claim();
        if arg == "--files" {
            source_managers.push(Vec::new());
        } else {
            source_managers.last_mut().unwrap().push(arg);
        }
    }

    // Now, run the fidlcrs compiler. We'll only use the last `source_managers` chunk
    // as the main files, and for now we'll only process the first file in it, like the old code did.
    // The previous implementation was:
    // let source = SourceFile::new(filename, content);
    // parser.parse_file(); ... JSON output.

    let mut filenames = Vec::new();
    for group in source_managers {
        filenames.extend(group);
    }

    if filenames.is_empty() {
        fail_with_usage("No files provided");
    }

    let mut source_files = Vec::new();
    for filename in &filenames {
        let content = match fs::read_to_string(filename) {
            Ok(c) => c,
            Err(e) => {
                eprintln!("Error reading file {}: {}", filename, e);
                process::exit(1);
            }
        };
        source_files.push(SourceFile::new(filename.to_string(), content));
    }

    let reporter = Reporter::new();
    let mut files = Vec::new();

    for source in &source_files {
        let mut lexer = Lexer::new(source, &reporter);
        let mut parser = Parser::new(&mut lexer, &reporter);

        parser
            .consume_token(TokenKind::StartOfFile)
            .expect("Failed to consume StartOfFile");

        match parser.parse_file() {
            Some(file) => files.push(file),
            None => {
                eprintln!("Failed to parse file: {}", source.filename());
                process::exit(1);
            }
        }
    }

    let mut compiler = Compiler::new();
    let source_refs: Vec<&SourceFile> = source_files.iter().collect();
    let json_root = compiler.compile(&files, &source_refs);

    let json_string = serde_json::to_string_pretty(&json_root).unwrap();

    if let Some(ref out_path) = json_path {
        if let Some(p) = std::path::Path::new(&out_path).parent() {
            fs::create_dir_all(p).unwrap_or(());
        }
        let mut f = match fs::File::create(out_path) {
            Ok(f) => f,
            Err(_e) => {
                fail(&format!("Could not open file: {}\n", out_path));
            }
        };
        f.write_all(json_string.as_bytes()).unwrap();
        f.write_all(b"\n").unwrap();
    }

    if let Some(dep_path) = dep_file_path {
        let mut f = fs::File::create(&dep_path).unwrap();
        if let Some(ref jp) = json_path {
            let input_files = filenames.join(" ");
            write!(f, "{} : {}\n", jp, input_files).unwrap();
        }
    }
}
